from flask import (
    Blueprint,
    render_template,
    request,
    flash,
    redirect,
    session,
    url_for,
    g,
    get_flashed_messages,
)
from werkzeug.security import check_password_hash, generate_password_hash
import uuid
import pyotp

from app.db import get_db
from app.helpers import confirm_2fa_pending

auth = Blueprint("auth", __name__)


@auth.before_app_request
def logged_in_user():
    user_id = session.get("user_id")
    if user_id is None:
        g.user = None
    else:
        g.user = (
            get_db().execute("SELECT * FROM users WHERE id = ?", (user_id,)).fetchone()
        )


class Credentials:
    def verify(self, fields):
        # Counter for missing credentials
        missing_credentials = 0
        # Iterate over the credentials
        for input, label in fields.items():
            if not request.form.get(f"{input}"):
                flash(f"Must provide {fields[input]}", "error")
                missing_credentials += 1
                continue
        if missing_credentials != 0:
            return False
        return True


class FlashMessages:
    def __init__(self):
        messages = get_flashed_messages(with_categories=True)
        if messages:
            for message in messages:
                flash(message)
        return


@auth.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        fields = {
            "first_name": "first name",
            "last_name": "last name",
            "username": "username",
            "password": "password",
            "password_check": "password confirmation",
        }

        # Check credentials
        if not Credentials().verify(fields):
            return redirect(url_for("auth.register"))

        db = get_db()
        credentials = {}
        role = "Inactive"

        # Stores key, value pairs in credentials dictionary according to fields keys
        for key, value in fields.items():
            # Makes sure the password is stored in the form of a hash value
            if fields[key] == "password":
                pwhash = generate_password_hash(request.form.get(f"{key}"))
                checker = check_password_hash(
                    pwhash, request.form.get("password_check")
                )
                if checker:
                    credentials[key] = pwhash
                else:
                    flash("Password and confirmation must be equal!", "error")
                    return redirect(url_for("auth.register"))

            else:
                credentials[key] = request.form.get(f"{key}")
        try:
            # This is a random identificator generated by uuid module
            # Proper documentation in:
            # https://docs.python.org/3/library/uuid.html
            UUID = str(uuid.uuid4()).upper()
            db.execute(
                """
                INSERT INTO users 
                    (username, password_hash, uuid, first_name, last_name, role)
                VALUES
                    (?,?,?,?,?,?)
                """,
                (
                    credentials["username"],
                    credentials["password"],
                    UUID,
                    credentials["first_name"],
                    credentials["last_name"],
                    role,
                ),
            )
            db.commit()
        except db.IntegrityError:
            flash("Username is already registered.", "error")
            return redirect(url_for("auth.register"))

        flash("User Registered!", "success")
        return redirect(url_for("auth.login"))
    else:
        FlashMessages()
        session.clear()
        return render_template("auth/register.html")


@auth.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        fields = {
            "username": "Username",
            "password": "Password",
        }

        # Check credentials
        if not Credentials().verify(fields):
            return redirect(url_for("auth.login"))

        username = request.form.get("username")
        password = request.form.get("password")

        db = get_db()
        rows = db.execute(
            """
            SELECT id, password_hash, totp_key
            FROM users
            WHERE username = (?)
            """,
            (username,),
        ).fetchone()

        # Checks if username is registered in database
        if rows is None:
            flash("Username not registered", "error")
            return redirect(url_for("auth.login"))

        auth = check_password_hash(rows["password_hash"], password)

        # Checks if password is valid
        if auth is not True:
            flash("Incorrect password", "error")
            return redirect(url_for("auth.login"))

        totp_key = rows["totp_key"]

        if totp_key is not None:
            session.clear()
            session["user_id_pending"] = rows["id"]
            return redirect(url_for("auth.confirm_2fa"))

        else:
            session.clear()
            session["user_id"] = rows["id"]
            return redirect(url_for("index"))
    else:
        FlashMessages()
        session.clear()
        return render_template("auth/login.html")


@auth.route("/confirm_2fa", methods=["GET", "POST"])
@confirm_2fa_pending
def confirm_2fa():
    if request.method == "POST":
        user_id = session["user_id_pending"]

        db = get_db()
        rows = db.execute(
            """
            SELECT id, totp_key
            FROM users
            WHERE id = (?)
            """,
            (user_id,),
        ).fetchone()

        totp_key = rows["totp_key"]

        try:
            user_input_code = int(request.form.get("totp"))
        except ValueError:
            flash("Must provide a valid 6-digit 2FA code", "error")
            return redirect(url_for("auth.confirm_2fa"))

        verify_otp = pyotp.TOTP(totp_key).verify(user_input_code)

        if verify_otp is True:
            session.clear()
            session["user_id"] = rows["id"]
            return redirect(url_for("index"))
        else:
            # Count for wrong attempts
            try:
                session["TRIES"] += 1
            except KeyError:
                session["TRIES"] = 1

            flash("Must provide a valid 6-digit 2FA code", "error")

            if session["TRIES"] >= 2:
                return redirect(url_for("auth.login"))
            else:
                return redirect(url_for("auth.confirm_2fa"))
    else:
        return render_template("auth/confirm_2fa.html")


@auth.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("auth.login"))


@auth.route("/recover", methods=["GET", "POST"])
def recover_account():
    if request.method == "POST":
        fields = {
            "username": "Username",
            "recovery": "Recovery key",
        }

        # Check credentials
        if not Credentials().verify(fields):
            return redirect(url_for("auth.recover_account"))

        input_username = request.form.get("username")
        input_recovery = request.form.get("recovery")

        db = get_db()
        try:
            db_recovery = db.execute(
                """
                SELECT uuid
                FROM users
                WHERE username = (?)
                """,
                (input_username,),
            ).fetchone()[0]
        except TypeError:
            flash("Username / Recovery key pair don't match!", "error")
            flash("Try again with valid input", "error")
            return redirect(url_for("auth.recover_account"))

        if input_recovery == db_recovery:
            session.clear()
            user_id = db.execute(
                """
                SELECT id
                FROM users
                WHERE username = (?)
                """,
                (input_username,),
            ).fetchone()

            session["recovery_id"] = user_id["id"]
            return redirect(url_for("auth.set_new_password"))
        else:
            flash("Username / Recovery key pair don't match!", "error")
            flash("Try again with valid input", "error")
            return redirect(url_for("auth.recover_account"))
    else:
        return render_template("auth/recover.html")


@auth.route("/set_password", methods=["GET", "POST"])
def set_new_password():
    if request.method == "POST":
        fields = {
            "password": "Password",
            "password_check": "Password confirmation",
        }

        # Check credentials
        if not Credentials().verify(fields):
            return redirect(url_for("auth.set_new_password"))

        pwhash = generate_password_hash(request.form.get("password"))
        checker = check_password_hash(pwhash, request.form.get("password_check"))

        # Checker if either True or False
        if checker:
            recovery_id = session["recovery_id"]
            session.clear()

            UUID = str(uuid.uuid4()).upper()
            db = get_db()
            totp_key = db.execute(
                """
                SELECT totp_key
                FROM users
                WHERE id = (?)
                """,
                (recovery_id,),
            ).fetchone()[0]

            db.execute(
                """
                UPDATE users
                SET password_hash = (?), uuid = (?), totp_key = NULL
                WHERE id = (?)
                """,
                (
                    pwhash,
                    UUID,
                    recovery_id,
                ),
            )
            db.commit()

            if totp_key is None:
                flash("New recovery key has been generated!", "success")
                flash("ALERT: Make sure to backup your new recovery key!", "success")
            else:
                flash("New recovery key has been generated!", "success")
                flash("ALERT: Make sure to backup your new recovery key!", "success")
                flash(
                    "ALERT: Two factor authentication has been deactivated!", "success"
                )

            session["user_id"] = recovery_id
            return redirect(url_for("user_profile.recovery_key"))
        # If not Checker
        else:
            flash("Password and confirmation must be equal!", "error")
            return redirect(url_for("auth.set_new_password"))
    else:
        try:
            if session["recovery_id"]:
                return render_template("auth/set_password.html")
        except KeyError:
            session.clear()
            flash("Please provide proper credentials", "error")
            return redirect(url_for("auth.recover_account"))
